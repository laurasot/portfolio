# Reglas del Proyecto - Astro con TypeScript

## 1. Estructura del Proyecto

```
src/
├── pages/          # Páginas de Astro (.astro, .md, .mdx) - definen rutas basadas en archivos
├── components/     # Componentes reutilizables
│   ├── *.astro    # Componentes Astro
│   └── react/     # Componentes de framework opcionales (si se usan islas de UI)
├── layouts/        # Layouts compartidos (.astro) para páginas
├── hooks/          # Hooks de framework (React) y utilidades reactivas (.ts/.tsx)
├── utils/          # Funciones auxiliares y utilidades (.ts)
├── styles/         # CSS global, utilidades, variables y tokens de diseño
│   ├── global.css
│   └── tokens.css
├── content/        # Colecciones de contenido (Astro Content Collections) si se usan
└── assets/         # Imágenes, fuentes, íconos, SVG, etc.

public/             # Archivos estáticos servidos tal cual (favicon, manifest, robots.txt)
tests/              # Pruebas unitarias e integradas, replicando la estructura de src/
```

## 2. Convenciones de Nombres

- **Componentes Astro**: PascalCase (`MiComponente.astro`)
- **Componentes de framework**: PascalCase (`MiBoton.tsx`)
- **Utilidades y hooks**: camelCase (`formatearFecha.ts`, `useObtenerDatos.ts`)
- **Layouts**: PascalCase (`BaseLayout.astro`)
- **CSS/SCSS**: BEM o CSS Modules con nombres en camelCase (`cardContainer`, `buttonPrimary`)
- **Tipos**: 
  - Definir interfaces y tipos en `.ts` o junto al componente (`MiComponente.types.ts`)
  - Tipos compartidos en carpeta `types/` si crece la base de tipos

## 3. Buenas Prácticas de Codificación

### TypeScript

- Usar TypeScript en:
  - Archivos `.ts` para lógica y utilidades
  - Archivos `.tsx` para componentes de framework (React, etc.)
  - Tipado en el frontmatter de archivos `.astro` cuando aplique
- Tipado estricto:
  - `strict: true` en `tsconfig.json`
  - Tipos explícitos para funciones, props de componentes e interfaces de datos

### Linting y Formateo

- **ESLint** con soporte para Astro y TypeScript:
  - `eslint-plugin-astro` para archivos `.astro`
  - `@typescript-eslint` para reglas específicas de TS
- **Prettier**:
  - Indentación de 2 espacios
  - Comillas simples
  - Integrado con `.astro`, `.ts`, `.tsx`, `.css`

### Principios SOLID

- **Single Responsibility**: cada módulo hace una sola cosa
- **Open/Closed**: extender sin modificar código existente
- **Liskov Substitution**: tipos derivados deben ser reemplazables sin romper la lógica
- **Interface Segregation**: interfaces pequeñas y específicas
- **Dependency Inversion**: la lógica de negocio no debe depender de detalles de infraestructura

### Componentes

- Preferir componentes simples y puros
- Lógica mínima en las páginas; extraer lógica a utilidades o componentes
- Mantener las páginas como composición de layouts + componentes
- Mantener el frontmatter de Astro limpio:
  - Importaciones ordenadas
  - Tipos de props bien definidos cuando se pasan datos a layouts o componentes

## 4. Patrones y Organización

### Separación de Responsabilidades

- **Páginas** (`src/pages`): estructura, rutas y composición de componentes
- **Componentes** (`src/components`): UI y lógica mínima asociada
- **Utilidades** (`src/utils`): lógica de negocio y funciones puras

### Islas de UI (Framework Components)

- Usar carpeta `src/components/react/` (o equivalente) para aislar esa tecnología
- Usar directivas de cliente de Astro de forma explícita y justificada:
  - `client:load` - carga inmediata
  - `client:idle` - carga cuando el navegador está inactivo
  - `client:visible` - carga cuando es visible
  - `client:only` - solo en cliente (evitar SSR)

### Evitar Duplicación

- Extraer lógica repetida a funciones reutilizables (`utils/`) o hooks (si se usa framework)

## 5. Gestión del Estado

### Estado Local (en islas de UI)

- En React: `useState`, `useReducer` con tipos explícitos
- En otros frameworks: usar sus mecanismos equivalentes correctamente tipados

### Estado Global

- Usar Context de React u otra solución solo dentro de las islas cuando realmente se requiera
- Para estados complejos, evaluar librerías como Redux Toolkit, Zustand, Jotai, etc., siempre encapsulados en las islas de UI

### Llamadas a APIs / Datos

- Preferir `getStaticPaths` y colecciones de contenido de Astro cuando se pueda resolver en build
- Dejar las llamadas dinámicas al cliente solo para casos necesarios (dashboards en tiempo real, formularios avanzados, etc.)

## 6. Estilos y Diseño

- Usar estilos globales mínimos (`styles/global.css`) y preferir:
  - CSS Modules
  - Tailwind CSS (si está integrado)
  - Utilidades propias de diseño (tokens, variables CSS)
- Mantener una escala de diseño consistente:
  - Paleta de colores, tipografía, espaciados, bordes, sombras, etc. definidos como tokens
- Evitar CSS inline innecesario en los componentes Astro

## 7. Accesibilidad y SEO

### Accesibilidad

- Usar HTML semántico: `header`, `main`, `section`, `nav`, `footer`, etc.
- Asegurar accesibilidad de teclado: todos los elementos interactivos deben ser alcanzables y usables con teclado
- Usar atributos `aria-*` solo cuando sean necesarios y con sentido
- Proveer `alt` descriptivo en las imágenes

### SEO

- Configurar meta-etiquetas desde los layouts o directamente en las páginas (`<head>` de Astro)
- Establecer `title`, `description`, `og:*`, `twitter:*` cuando corresponda
- Usar sitemap, robots.txt y otros archivos de soporte SEO desde `public/` o integraciones de Astro

## 8. Rendimiento y Escalabilidad

### Características de Astro

- Generación estática por defecto
- Partial Hydration: solo hidratar componentes cuando sea necesario
- Usar directivas `client:*` con criterio, evitando hidratar componentes que no lo necesitan

### Optimización de Imágenes

- Usar `@astrojs/image` o `astro:assets` para optimizar imágenes (formatos modernos, tamaños adecuados)

### Optimización de Islas de UI

- En React, usar `React.memo`, `useMemo`, `useCallback` solo cuando el beneficio esté claro
- Evitar renders innecesarios

### Arquitectura Escalable

- Módulos independientes, reutilizables y testeables
- Documentar convenciones y decisiones de arquitectura

## 9. Despliegue

### Build

- Construir con: `npm run build` / `pnpm build` / `yarn build`
- Configurar adaptadores según el destino: Static, Vercel, Netlify, SSR, etc.

### Hosting

- Desplegar los archivos generados (`dist/`) en servicios compatibles:
  - Vercel, Netlify, Cloudflare Pages, etc.

### Variables de Entorno

- Usar el sistema de variables de entorno de Astro
- Mantener nombres consistentes y evitar exponer secretos en el cliente
- Solo exponer variables públicas que empiecen con `PUBLIC_` (convención de Astro)

## 10. Reglas de Código

### Comentarios

- Sin comentarios innecesarios: el código debe ser autoexplicativo mediante buenos nombres
- Se permiten comentarios solo cuando aporten contexto que no se pueda derivar del código

### Prohibiciones

- **Prohibido usar emojis** en el código, documentación técnica o nombres de archivos

### Limpieza de Código

- Eliminar código no utilizado: nada de funciones, componentes o imports muertos
- Limpiar archivos y módulos al refactorizar

### Reutilización

- Extraer lógica repetitiva a utilidades (`utils/`) o hooks de framework (en islas) para evitar duplicación

### Consistencia

- Mantener una estructura y estilo consistentes
- Seguir las reglas de ESLint y Prettier sin desactivarlas salvo casos muy justificados
